### Java-wangzheng



如何学习、看书

>1.第一阶段目标是能看懂，没有太多疑问看一遍 1
>
>2.第二阶段目标是能够添加联想看懂
>
>3.第三阶段目标是看着小标题和大标题能够知道讲了什么,从看着小标题能写出来到看着大标题能写出来
>
>4.不断重构



#### 一、代码执行，CPU、操作系统、虚拟机



##### 1.1 解释型、编译型，混合型语言（掌握）

CPU只能执行机器指令，所有高级语言都必须编译成机器指令

1.编译型：直接编译成机器指令 ——> CPU执行

2.解释型：不编译成机器指令——>执行时通过虚拟机解释代码为机器指令——>CPU执行

3.混合型：编译为中间文件——>执行时虚拟机解释代码为机器指令——>CPU执行。



##### 1.2 CPU、操作系统、虚拟机（掌握）

CPU 执行机器指令，完成计算

操作系统 调度系统资源，同时提供封装好的类库，隔离底层操作

虚拟机 是可以由CPU执行的机器指令，负责编译解释高级语言。



##### 1.3 CPU指令、汇编、字节码（掌握）

CPU 指令包含操作码、地址、数据，CPU直接执行

汇编一一对应CPU指令，方便程序员理解

字节码对汇编语言进行了一定封装，屏蔽不同平台的细节



##### 1.4 代码如何被CPU执行（熟悉）

###### 1.4.1 有哪些寄存器，分别的作用是啥（熟悉）

总结：根据英文名区分，最后一个字符是

>X 通用寄存器
>
>P Pointer 指针寄存器
>
>I Index 指针寄存器
>
>S Sgement 段寄存器

1.通用寄存器：AX,BX,CX,DX 一般用来存储普通数据

>AX （Accumulator）  累加器
>
>BX （Base Register） 基址寄存器
>
>CX （Count Register） 常用计数器
>
>DX（ Data Register） 存放数据

2.指针寄存器：BP,SP,SI,DI,IP 

> BP（Base Pointer Register） 一般存储栈底地址
>
> SP（Stack Pointer Register）栈顶地址
>
> SI（Source Index Register） 源地址寄存器，读取数据的内存地址
>
> DI（Destination Index Register）目的地址寄存器 写入数据的内存地址
>
> IP（Instruction Pointer Register）指针指令寄存器 记录下一条指令的内存地址

3.段寄存器 CS DS SS

程序=数据+指令，存数据的内存为数据段，存指令的内存为代码段

>CS （Code Segment Register） CS+IP 可以计算出真正的物理地址  物理内存地址=CS*16 + IP，结合起来等价于PC(Program Counter Register)寄存器
>
>DS（Data Segment Register）DS+DI/DS+SI 确定真正的数据内存地址
>
>SS（Stack Segment Register）SS+SP/SS+BP 确定真正的栈内存地址

4.指令寄存器IR（Instruction Register）指令寄存器

指令为一串二进制码，需要从指令中解析出操作码、操作地址和操作数，所以需要IR

5.标志寄存器FR（Flag Register）

###### 1.4.2 CPU指令执行流程（陌生）

对于编译型的语言，操作系统将机器指令数据放入内存中的代码段，将数据放入数据段并初始化对应寄存器，DS,CS，将第一条指令的内存地址存入IP寄存器。

CPU根据PC寄存器取出指令，放入IR指令寄存器，PC寄存器地址偏移+4或者+8。执行完一条指令后，再通过PC寄存器继续取出指令执行，直到执行完成。

对于解释型语言

虚拟机程序本身就是机器码，执行过程中将高级语言翻译成机器码放到对应的代码段，最后引导CPU执行解释出来的代码。

##### 1.5 思考（未知）

C++为什么先编译成汇编，再编译成机器指令，是否多次一举？

>1.提升一定的可读性，但是不是特别有必要，高级语言的可读性更强



##### 泛型

传统的类和方法使用基本数据类型和类类型数据。

通过典型的面向对象工具:多态，可以使代码更加具有扩展性，代码base类作为入参，可传入任何继承base类的对象，实现灵活和扩展性。

继承是一种较强的耦合方式，使用接口+接口隔离原则可实现更加松散的耦合方式。

即使使用接口，你也必须实现接口中的方法，有没有一种办法可以以未指定的类类型使代码工作起来。

泛型的一个原始动机是限定collection持有的对象的类型



#### 二、CPU如何看待程序各属性

##### 2.1 变量

内存被划分成内存单元，代码通过内存地址访问内存中的数据，内存地址不符合人类阅读习惯，将变量与内存地址一一映射，增加代码可读性。

##### 2.2 函数

刚进入fa函数时，将sp地址-8，将rbp寄存器的值放入到rsp存储的值对应的内存单元中（是不是为了返回）



#### 十九、 IO掌握逻辑

>1.按照流向分类，输入输出流
>
>2.按照读写单位分类，字节字符流。为了字节和字符流设计两套类是没有必要的，因为IO读写方式是相同的知识解析方式不同而已
>
>3.原始类和装饰器类



#### 二十、 BIO NIO AIO 原理

##### 1. NIO四个核心概念

**Buffer**本质上是一块内存，不同的Buffer有不同的解析数据的方式

**Channel**用于读取数据，可读可写，stream是单向的，Channel有两种运行模式，阻塞模式和非阻塞模式

**Selector**在网络编程中，非阻塞模式下，线程需要通过while循环不断轮询调用read()、write()、accept()。使用多路复用模型，将需要监听的Channel regist

**异步Channel**，Selector底层依然使用轮询处理，异步直接使用回调

##### 2. 阻塞和非阻塞的区别

首先数据会在IO设备，内核缓冲区，应用程序缓冲区三者间拷贝。

**阻塞**是指调用read()函数后，如果内核缓冲区没有数据，会等到直到内核缓冲区有数据为止。

**非阻塞**会直接返回，同时报告读取情况





#### 二十八、进程线程演化

进程实际上是程序运行过程中对所涉及的数据、代码、资源、执行信息的封装，起到方便管理的作用。

##### 1. 进程、线程演化路径及对应背景

###### 1.1 单进程

> 早期多是科学计算(CPU密集型计算)，多进程对代码执行效率优化作用不大
>
> 科学计算对实时性要求不高

###### 1.2 多进程

随着计算机大规模普及，用户对响应时间的要求提高，多个进程同时运行可使用户在多个APP间“快速”切换使用

###### 1.3 多线程

多进程已经很好的满足了多个程序并发执行的需求。线程的引入完全是在设计、性能、易用性上的进一步优化。

**在设计方面**，进程负责线程共享资源的管理，线程负责代码的执行。

**在性能方面**，随着多核CPU的发展，让程序并行运行在多个CPU上，比如IO和计算指令同时执行。

**在易用性方面**，引入多线程后，每个程序负责执行一个逻辑，多个逻辑之间的调度由操作系统完成。如果没有多线程，调度需要程序员自己去维护。

##### 2. 调度策略



#### 二十九、线程模型

线程模型的衡量依据在于线程的调度由谁执行，如果是操作系统内核进行调度，则是内核线程。

进程的地址空间分为用户的地址空间和内核的地址空间。程序在用户空间执行时，CPU处于用户态，程序在内核空间执行时，CPU处于内核态。

对于应用程序来说，其运行在用户空间无法直接操作内核线程，只能调用操作系统封装的线程函数。

所以每种语言都会创建一种线程与操作系统内核线程一一对应。



