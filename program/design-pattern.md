#### Design pattern

##### 理解SOLID

>Simple Responsbility Principle : A class should have only one reason to change 。
>
>Open -closed Principle
>
>The Liskov Substitution Principle
>
>Interface Segregation Principle
>
>Dependence Inversion principle

职则单一：变化原因只有一个。重点在于分离关注点

达到里式替换原则，需要接口隔离原则

依赖倒置原则指导实现接口隔离原则



##### 1.如何精准命名

少使用技术细节，比如bookList->books。缓存

好的命名表达意图，而非细节，使用业务语言书写代码，框架等大量底层代码使用技术语言是因为技术本身就是其代码的业务。好的命名是体现业务含义的命名。

##### 6.处理长参数

封装参数，模型的封装应该是以行为为基础的，这些参数属于同一个类，有相同的变化原因



#### 模式为什么这么设计，解决什么问题
#####  创建型
###### 1. 简单工厂模式

将对象的创建抽离到工厂类中，使创建行为更加单一

###### 2. 工厂方法模式

当创建行为非常复杂时，对创建行为本身进行抽象，产品维度提供一个接口用于创建不同产品。同时不同工厂也抽象一个接口，便于创建工厂。此时对于工厂来说使用的是简单工厂模式。

###### 3. 抽象工厂模式

将能提取的工厂类取消，同一工厂能创建多种具有相似性的产品。比如bean的创建可以根据xml解析，也可以根据注解解析，此两种方式生成bean可以使用同一个工厂。

###### 4. builder模式

>构造必传参数过多，防止构造器参数列表过长
>
>参数构造初始化有依赖，防止对象存在无效状态，比如正方形只有长
>
>不可变对象不暴露set，必须一次性初始化参数

###### 5. 原型模式

对象创建成本较高，同时内存中存在可以copy的对象
##### 结构型
###### 1. 代理模式

非功能性需求，业务与通用的功能分离，比如统计，鉴权等等

###### 2. 桥接模式

一个类存在两个或者多个独立变化的维度，将两个类分离，使用组合的方式便于每个维度单独扩展

###### 3. 装饰器模式

为原始类增强不同维度的功能，继承同一接口，同时组合传入此接口继承类

###### 4. 适配器模式

分为类适配器和对象适配器。类适配器基于继承，适配器直接调用父类方法完成适配；对象适配器基于组合，适配器通过组合调用对应方法

适配器模式用于解决：

> 封装更底层的有缺陷的接口设计，不好改动的。
>
> 统一多个功能相同相似类的接口设计
>
> 替换第三方接口

