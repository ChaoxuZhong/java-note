### Java concurrent

##### Q 线程和进程的区别

进程和线程的本质区别是：是否单独占用内存空间及其他系统资源（如IO）。

> 进程有独立的内存空间，进程间内存隔离，共享数据复杂但是同步简单。
>
> 线程有共享的内存空间，共享数据简单同步复杂。

进程是操作系统进行资源分配的基本单位，线程是操作系统调度的基本单位。

进程的创建和销毁不仅需要保存寄存器和栈的信息，还需要资源的分配和销毁，开销较大；线程只需要保存寄存器和栈的信息，开销较小。



##### Q Java内存区域的划分

>程序计数器：控制记录程序执行流程
>
>本地方法栈：存储本地native（C）代码的调用栈
>
>虚拟机栈：存储Java方法的调用栈
>
>堆：存放创建好的Java对象
>
>方法区:已被虚拟机加载的类，常量，静态变量，即时编译器编译后的代码缓存等



##### Q 并行与并发的区别

>并行：同一时刻有多个线程在同时运行程序
>
>并发：同一时间段内有多个线程因CPU时间片调度在同时执行



##### Q 为什么要使用多线程

1.假设是有一个CPU，多线程可以充分利用CPU与内存、IO 设备之间的速度差异，单位时间内并发执行更多的程序，加速程序。

2.多CPU的情况下，充分利用多核CPU，提高计算密集型程序的效率。



##### Q 操作系统、Java中  线程生命周期

**操作系统中：初始化(new)——>就绪(ready)——> 执行(running)——>等待(waiting)——>终止(terminated)**

 **我理解操作系统的状态是围绕CPU来定义的。**（掌握不完全）

> 就绪状态：线程正在等待使用CPU
>
> 执行状态：线程正在使用CPU
>
> 等待状态：IO操作

Java中：初始化(new)——> 可运行状态(runnable)  ——> 阻塞(blocked)——> 等待(waiting) ——> 超时等待(timed-waiting) ——> 终止(terminated)

对于JVM 来说等待IO的时候，也是runnable状态，因为IO的调度是操作系统的事情。



##### Q 死锁产生的条件

> 1.互斥条件：对共享资源的访问是互斥的(锁嘛，肯定是互斥的)
>
> 2.占有且等待：线程占有某一资源时，请求另一资源时，不释放当前资源
>
> 3.不可抢占：其他线程不能抢占已占有资源线程的资源
>
> 4.循环等待：线程对资源的请求形成环



##### Q 如何防止、破坏死锁 （掌握不完全）

>1.破坏占有且等待：一次性申请所有资源，不存在等待；加超时时间，也会在等待时释放锁
>
>2.破坏不可抢占：使用可抢占的锁
>
>3.循环等待：按顺序等待，但是可能造成饥饿



##### Q 并发程序为什么会有问题

>1.缓存带来的可见性问题 （可使用JMM Java内存模型解释）
>
>2.编译器优化带来的有序性问题
>
>3.线程切换带来的原子性问题



##### Q ThreadLocal 原理

思路：同一段代码，不同线程需要有不同的值，所以存放的值应该与线程某唯一标识关联起来。

有两种关联方式

>1.每个线程中存放属于线程的值，实际实现上每个线程拥有一个ThreadLocalMap，ThreadLocal为key，则value为对应的值
>
>2.ThreadLocal中维护属于某个线程的值，那么ThreadLocal便需要维护一个ThreadLocalMap，key是线程ID，value为每个线程的值。

当前为第1种情况。



##### Q ThreadLocalMap 的key 为什么要设计为弱引用(掌握不完全）

当栈没有引用ThreadLocalMap中的key时，key中引用的ThreadLocal会自动垃圾回收为null，防止内存泄露。

![thread-local-map](/Users/chaoxu/Documents/Life/note/program/image/thread-local-map.png)



##### Q 对象头和获得锁的关系(掌握不完全）

![image-20220408170749582](/Users/chaoxu/Documents/Life/note/program/image/object-mark-word.png)



##### Q synchronize锁有哪些锁，特点分别是什么

> 偏向锁：检测访问临界区的是否为当前线程，是直接放行，不是回去CAS吗？
>
> 轻量级锁：会在栈中创建LockRecord，LockRecord中信息与对象头的MarkWord进行cas交换，换成功了获得轻量级锁，不成功锁升级。
>
> 重量级锁：对象头markword中存放重量级锁monitor的指针。

锁升级的过程是怎么样的？

当轻量级锁并发访问共享资源时，其中一个线程获取不到锁，发现markword中有其他线程栈的锁记录。将锁更新为重量级锁
